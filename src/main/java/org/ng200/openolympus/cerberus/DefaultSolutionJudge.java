/**
 * The MIT License
 * Copyright (c) 2014-2016 Nick Guletskii
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.ng200.openolympus.cerberus;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;

import org.ng200.openolympus.FileAccess;
import org.ng200.openolympus.SharedTemporaryStorage;
import org.ng200.openolympus.SharedTemporaryStorageFactory;
import org.ng200.openolympus.cerberus.compilers.Compiler;
import org.ng200.openolympus.cerberus.compilers.FPCCompiler;
import org.ng200.openolympus.cerberus.compilers.GNUCompiler;
import org.ng200.openolympus.cerberus.compilers.JavaCompiler;
import org.ng200.openolympus.cerberus.exceptions.CompilationException;
import org.ng200.openolympus.cerberus.exceptions.CompilerError;
import org.ng200.openolympus.cerberus.executors.JavaExecutor;
import org.ng200.openolympus.cerberus.executors.OpenOlympusWatchdogExecutor;
import org.ng200.openolympus.cerberus.executors.SandboxedExecutor;
import org.ng200.openolympus.cerberus.util.Lists;
import org.ng200.openolympus.cerberus.util.TemporaryStorage;
import org.ng200.openolympus.cerberus.verifiers.FileExistsVerifier;
import org.ng200.openolympus.cerberus.verifiers.WhitespaceTokenizedVerifier;

/**
 * 
 * Default solution judge. Handles normal tasks which require the solution to be
 * compiled, ran and finally, the answers to be checked.
 * 
 * Supports the following solution file formats:
 * <ul>
 * <li>GNU C++ source file (file name must end with .cpp)</li>
 * <li>FPC source file (file name must end with .pas)</li>
 * <li>Java source file (file name must be Main.java)</li>
 * </ul>
 *
 * You can override many parts of this judge to customise it.
 * 
 * Default configuration parameters:
 * <ul>
 * <li>cpuTimeLimit</li>
 * <li>realTimeLimit</li>
 * <li>memoryLimit</li>
 * <li>diskLimit</li>
 * </ul>
 *
 * @author Nick Guletskii
 */
public class DefaultSolutionJudge extends SolutionJudge {
	private static enum ProgramLanguage {
		CPP, FPC, JAVA
	}

	/**
	 *
	 */
	private static final long serialVersionUID = -6077008331283504808L;

	private transient TemporaryStorage storage;
	private SharedTemporaryStorage sharedStorage;
	private String inputFileName;
	private String outputFileName;
	private Path program;
	private boolean consoleInput;
	private String charset;
	private SolutionResultBuilder baseResultBuilder = new SolutionResultBuilder();

	private Boolean compiled = false;

	private ProgramLanguage programLanguage = null;

	private boolean deduplicateWhitespace;

	/**
	 * Constructor used by the serialisation layer. Please don't call this
	 * directly.
	 */
	public DefaultSolutionJudge() {
		// Serialization constructor
	}

	/**
	 * 
	 * @param consoleInput
	 *            If false, the judge will pass the test's input file to the
	 *            solution and get the solution's output as a file.
	 * 
	 *            If true, the judge will pass the test's input file to the
	 *            solution through standard input and retrieve the solution's
	 *            output through standard output.
	 * @param inputFileName
	 *            Name of the file that will be passed as input to the solution.
	 *            Should be null if consoleInput is true.
	 * @param outputFileName
	 *            Name of the file that will be generated by the solution.
	 *            Should be null if consoleInput is true.
	 * @param charset
	 *            The charset to use when processing test data.
	 * @param storageFactory
	 *            The storage factory. {@see SharedTemporaryStorageFactory}
	 * @param deduplicateWhitespace
	 *            If true, the checker will remove duplicate whitespace in the
	 *            output file before checking the answer.
	 * @throws IOException
	 */
	public DefaultSolutionJudge(final boolean consoleInput,
			final String inputFileName, final String outputFileName,
			final String charset,
			final SharedTemporaryStorageFactory storageFactory,
			boolean deduplicateWhitespace)
			throws IOException {
		this.inputFileName = inputFileName;
		this.outputFileName = outputFileName;
		this.consoleInput = consoleInput;
		this.charset = charset;
		this.sharedStorage = storageFactory.createSharedTemporaryStorage();
		this.program = this.sharedStorage.getPath().resolve("program");
	}

	/**
	 * Convenience method for checking answers which is called by both file
	 * checking and standard output checking methods.
	 * 
	 * @param resultBuilder
	 * @param inputFile
	 *            Path to the test's input file. The file may reside on a remote
	 *            filesystem, which means that it can't be converted into a
	 *            java.io.File.
	 * 
	 *            IO speed is not guaranteed.
	 * 
	 *            Any write operations are prohibited.
	 * @param outputFile
	 *            Path to the test's expected output file. The file may reside
	 *            on a remote filesystem, which means that it can't be converted
	 *            into a java.io.File.
	 * 
	 *            IO speed is not guaranteed.
	 * 
	 *            Any write operations are prohibited.
	 * @param bufferedReader
	 *            Output produced by the solution.
	 * @param maximumScore
	 *            Maximum score for the test.
	 */
	protected void checkAnswer(final SolutionResultBuilder resultBuilder,
			final Path inputFile, Path outputFile,
			final BufferedReader bufferedReader,
			final BigDecimal maximumScore) {
		resultBuilder.checkingStage(
				() -> {
					return new WhitespaceTokenizedVerifier(outputFile,
							isDeduplicateWhitespace(), true)
									.isAnswerCorrect(bufferedReader,
											Charset.forName(this.charset));
				}).checkingStage(
						() -> {
							resultBuilder.setScore(maximumScore);
							return new VerifierResult(
									AnswerCheckResult.CheckingResultType.OK,
									"Successful judgement.");
						});
	}

	/**
	 * Checks the answer written to a file.
	 * 
	 * @param resultBuilder
	 * @param inputFile
	 *            Path to the test's input file. The file may reside on a remote
	 *            filesystem, which means that it can't be converted into a
	 *            java.io.File.
	 * 
	 *            IO speed is not guaranteed.
	 * 
	 *            Any write operations are prohibited.
	 * @param outputFile
	 *            Path to the test's expected output file. The file may reside
	 *            on a remote filesystem, which means that it can't be converted
	 *            into a java.io.File.
	 * 
	 *            IO speed is not guaranteed.
	 * 
	 *            Any write operations are prohibited.
	 * @param userOutputFile
	 * @param maximumScore
	 *            Maximum score for the test.
	 * @throws IOException
	 */
	private void checkAnswerFile(final SolutionResultBuilder resultBuilder,
			final Path inputFile, final Path outputFile,
			final Path userOutputFile, final BigDecimal maximumScore)
			throws IOException {
		try (BufferedReader solutionOutputReader = FileAccess
				.newBufferedReader(userOutputFile);) {
			this.checkAnswer(resultBuilder, inputFile, outputFile,
					solutionOutputReader, maximumScore);
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.ng200.openolympus.cerberus.SolutionJudge#closeLocal()
	 */
	@Override
	public void closeLocal() throws IOException {
		this.getStorage().close();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.ng200.openolympus.cerberus.SolutionJudge#closeShared()
	 */
	@Override
	public void closeShared() throws IOException {
		this.sharedStorage.close();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.ng200.openolympus.cerberus.SolutionJudge#compile(java.util.List,
	 * java.util.Properties)
	 */
	@Override
	public void compile(final List<Path> sources, Properties properties) {
		synchronized (this.compiled) {
			this.baseResultBuilder
					.compileStage(() -> {
						if (sources.size() != 1) {
							throw new IllegalArgumentException(
									"DefaultSolutionJudge only supports one source file!");
						}
						final Path sourceFile = sources.get(0);

						if (sourceFile.getFileName().toString()
								.endsWith(".cpp")) {
							final Path temporaryCopy = this.sharedStorage
									.getPath().resolve("main.cpp");

							FileAccess.copy(sources.get(0), temporaryCopy);

							this.programLanguage = ProgramLanguage.CPP;
							return this.compileCpp(temporaryCopy);
						} else if (sourceFile.getFileName().toString()
								.endsWith(".pas")) {
							final Path temporaryCopy = this.sharedStorage
									.getPath().resolve("main.pas");

							FileAccess.copy(sources.get(0), temporaryCopy);

							this.programLanguage = ProgramLanguage.FPC;
							return this.compileFpc(temporaryCopy);
						} else if (sourceFile.getFileName().toString()
								.endsWith(".java")) {
							final Path temporaryCopy = this.sharedStorage
									.getPath().resolve("Main.java");

							FileAccess.copy(sources.get(0), temporaryCopy);

							this.programLanguage = ProgramLanguage.JAVA;
							return this.compileJava(temporaryCopy);
						} else {
							return new CompilerResult(
									CompilerResult.CompileResultType.COMPILE_ERROR,
									new CompilerError("Unknown file type",
											"Please check the file type."));
						}
					});
		}
	}

	/**
	 * Compiles a source file using a specific compiler.
	 * 
	 * @param sourceFile
	 *            The source file to compile
	 * @param compiler
	 *            The compiler to use
	 * @return Compilation result.
	 * @throws CompilationException
	 * @throws IOException
	 */
	private CompilerResult compile(final Path sourceFile,
			final Compiler compiler) throws CompilationException, IOException {
		assert FileAccess.exists(sourceFile);
		CompilerResult result;
		try {
			compiler.compile(Lists.from(sourceFile), this.program,
					new HashMap<String, Object>());

			result = new CompilerResult(CompilerResult.CompileResultType.OK);

			this.compiled = true;
		} catch (final CompilerError error) {
			result = new CompilerResult(
					CompilerResult.CompileResultType.COMPILE_ERROR, error);
		}
		return result;
	}

	/**
	 * Compile using the GNU C++ compiler.
	 * 
	 * @param sourceFile
	 * @return Compilation result.
	 * @throws CompilationException
	 * @throws IOException
	 */
	private CompilerResult compileCpp(final Path sourceFile)
			throws CompilationException, IOException {
		final GNUCompiler compiler = new GNUCompiler();
		compiler.addArgument("-O2");
		return this.compile(sourceFile, compiler);
	}

	/**
	 * Compile using the FPC compiler.
	 * 
	 * @param sourceFile
	 * @return Compilation result.
	 * @throws CompilationException
	 * @throws IOException
	 */
	private CompilerResult compileFpc(final Path sourceFile)
			throws CompilationException, IOException {
		final FPCCompiler compiler = new FPCCompiler();
		compiler.addArgument("-O2");
		return this.compile(sourceFile, compiler);
	}

	/**
	 * Compile using the Java compiler.
	 * 
	 * @param sourceFile
	 * @return Compilation result.
	 * @throws CompilationException
	 * @throws IOException
	 */
	private CompilerResult compileJava(final Path sourceFile)
			throws CompilationException, IOException {
		return this.compile(sourceFile, new JavaCompiler());
	}

	/**
	 * @param testFiles
	 *            The files for the test the solution is currently being tested
	 *            on.
	 * @param resultBuilder
	 * @param checkAnswer
	 *            <b>true</b> if the testing supervisor has requested the answer
	 *            to be checked for correctness.
	 * 
	 *            <b>false</b> if the testing supervisor isn't interested in
	 *            verifying the correctness of the solution's answer.
	 * @param maximumScore
	 *            The maximum score that the solution judge can award for this
	 *            test.
	 * @param properties
	 *            Task configuration properties.
	 */
	private void executeWithConsoleInput(final List<Path> testFiles,
			final SolutionResultBuilder resultBuilder,
			final boolean checkAnswer, final BigDecimal maximumScore,
			final Properties properties) {

		final Path outputFile = testFiles
				.stream()
				.filter((file) -> file.getFileName().toString()
						.equals(this.outputFileName))
				.findAny()
				.orElseThrow(
						() -> new IllegalArgumentException(
								"Output file is not supplied"));

		final Path inputFile = testFiles
				.stream()
				.filter((file) -> file.getFileName().toString()
						.equals(this.inputFileName))
				.findAny()
				.orElseThrow(
						() -> new IllegalArgumentException(
								"Input file is not supplied"));

		final ByteArrayOutputStream out = new ByteArrayOutputStream();
		final ByteArrayOutputStream err = new ByteArrayOutputStream();

		try (InputStream in = FileAccess.newBufferedInputStream(inputFile);
				OpenOlympusWatchdogExecutor executor = this.getExecutor()) {
			resultBuilder.runtimeStage(() -> {
				executor.setCpuLimit(
						Long.valueOf(properties.getProperty("cpuTimeLimit")))
						.setTimeLimit(
								Long.valueOf(properties
										.getProperty("realTimeLimit")))
						.setMemoryLimit(
								Long.valueOf(properties
										.getProperty("memoryLimit")))
						.setDiskLimit(
								Long.valueOf(properties
										.getProperty("diskLimit")));

				executor.setOutputStream(out).setErrorStream(err)
						.setInputStream(in);
				return executor.execute(this.program);
			});
			if (checkAnswer) {
				try (BufferedReader solutionOutputReader = new BufferedReader(
						new InputStreamReader(
								new ByteArrayInputStream(out.toByteArray())))) {
					this.checkAnswer(resultBuilder, inputFile, outputFile,
							solutionOutputReader, maximumScore);
				}
			}
		} catch (final IOException e) {
			throw new RuntimeException(
					"Couldn't execute and check user's solution: ", e);
		}

	}

	/**
	 * @param testFiles
	 *            The files for the test the solution is currently being tested
	 *            on.
	 * @param resultBuilder
	 * @param checkAnswer
	 *            <b>true</b> if the testing supervisor has requested the answer
	 *            to be checked for correctness.
	 * 
	 *            <b>false</b> if the testing supervisor isn't interested in
	 *            verifying the correctness of the solution's answer.
	 * @param maximumScore
	 *            The maximum score that the solution judge can award for this
	 *            test.
	 * @param properties
	 *            Task configuration properties.
	 */
	private void executeWithFiles(final List<Path> testFiles,
			final SolutionResultBuilder resultBuilder,
			final boolean checkAnswer, final BigDecimal maximumScore,
			final Properties properties) {
		final Path outputFile = testFiles
				.stream()
				.filter((file) -> file.getFileName().toString()
						.equals(this.outputFileName))
				.findAny()
				.orElseThrow(
						() -> new IllegalArgumentException(
								"Output file is not supplied"));

		final Path inputFile = testFiles
				.stream()
				.filter((file) -> file.getFileName().toString()
						.equals(this.inputFileName))
				.findAny()
				.orElseThrow(
						() -> new IllegalArgumentException(
								"Input file is not supplied"));

		Path userOutputFile;
		try {
			userOutputFile = this.getStorage().getPath()
					.resolve(this.outputFileName + ".user");
		} catch (final IOException e) {
			throw new RuntimeException(e);
		}

		try (OpenOlympusWatchdogExecutor executor = this.getExecutor()) {

			resultBuilder.runtimeStage(() -> {
				executor.setCpuLimit(
						Long.valueOf(properties.getProperty("cpuTimeLimit")))
						.setTimeLimit(
								Long.valueOf(properties
										.getProperty("realTimeLimit")))
						.setMemoryLimit(
								Long.valueOf(properties
										.getProperty("memoryLimit")))
						.setDiskLimit(
								Long.valueOf(properties
										.getProperty("diskLimit")));

				executor.setOutputStream(null).setErrorStream(null)
						.setInputStream(null);

				executor.provideFile(inputFile);
				final ExecutionResult result = executor.execute(this.program);
				return result;
			});

			resultBuilder
					.checkingStage(
							() -> FileExistsVerifier
									.noFileNotFoundException(() -> executor
											.getFile(this.outputFileName,
													userOutputFile)))
					.checkingStage(
							() -> FileExistsVerifier
									.fileExists(userOutputFile));
			if (checkAnswer) {
				this.checkAnswerFile(resultBuilder, inputFile, outputFile,
						userOutputFile, maximumScore);
			}
		} catch (final IOException e) {
			throw new RuntimeException(
					"Couldn't execute and check user's solution: ", e);
		}
	}

	/**
	 * @return the result builder base to use to build every test's result.
	 */
	public SolutionResultBuilder getBaseResultBuilder() {
		return this.baseResultBuilder;
	}

	public String getCharset() {
		return this.charset;
	}

	public Boolean getCompiled() {
		return this.compiled;
	}

	/**
	 * @return the current solution result of the base result builder.
	 */
	public SolutionResult getCurrentStatus() {
		return this.baseResultBuilder.build();
	}

	private OpenOlympusWatchdogExecutor getExecutor() throws IOException {
		if (this.programLanguage == null) {
			throw new IllegalStateException(
					"Unknown file type: should've failed during compilation.");
		}
		switch (this.programLanguage) {
		case CPP:
		case FPC:
			return new SandboxedExecutor(this);
		case JAVA:
			if (this.consoleInput) {
				return new JavaExecutor(this, Lists.from());
			} else {
				return new JavaExecutor(this, Lists.from(this.outputFileName));
			}
		}
		return null;
	}

	public String getInputFileName() {
		return this.inputFileName;
	}

	public String getOutputFileName() {
		return this.outputFileName;
	}

	public Path getProgram() {
		return this.program;
	}

	public ProgramLanguage getProgramLanguage() {
		return this.programLanguage;
	}

	public SharedTemporaryStorage getSharedStorage() {
		return this.sharedStorage;
	}

	private synchronized TemporaryStorage getStorage() throws IOException {
		if (this.storage == null) {
			this.storage = new TemporaryStorage(this);
		}
		return this.storage;
	}

	@Override
	public boolean isCompiled() {
		synchronized (this.compiled) {
			return this.compiled;
		}
	}

	public boolean isConsoleInput() {
		return this.consoleInput;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.ng200.openolympus.cerberus.SolutionJudge#run(java.util.List,
	 * boolean, java.math.BigDecimal, java.util.Properties)
	 */
	@Override
	public SolutionResult run(final List<Path> testFiles,
			final boolean checkAnswer, final BigDecimal maximumScore,
			final Properties properties) {
		if (!this.baseResultBuilder.getShouldContinue()) {
			return this.baseResultBuilder.build();
		}

		final SolutionResultBuilder resultBuilder = SolutionResultBuilder
				.copyOf(this.baseResultBuilder);
		if (this.consoleInput) {
			this.executeWithConsoleInput(testFiles, resultBuilder, checkAnswer,
					maximumScore, properties);
		} else {
			this.executeWithFiles(testFiles, resultBuilder, checkAnswer,
					maximumScore, properties);
		}
		return resultBuilder.build();
	}

	public void setBaseResultBuilder(SolutionResultBuilder baseResultBuilder) {
		this.baseResultBuilder = baseResultBuilder;
	}

	/**
	 * Sets the charset to use when reading the test data.
	 * 
	 * @param charset
	 */
	public void setCharset(String charset) {
		this.charset = charset;
	}

	public void setCompiled(Boolean compiled) {
		this.compiled = compiled;
	}

	public void setConsoleInput(boolean consoleInput) {
		this.consoleInput = consoleInput;
	}

	public void setInputFileName(String inputFileName) {
		this.inputFileName = inputFileName;
	}

	public void setOutputFileName(String outputFileName) {
		this.outputFileName = outputFileName;
	}

	public void setProgram(Path program) {
		this.program = program;
	}

	public void setProgramLanguage(ProgramLanguage programLanguage) {
		this.programLanguage = programLanguage;
	}

	public void setSharedStorage(SharedTemporaryStorage sharedStorage) {
		this.sharedStorage = sharedStorage;
	}

	public boolean isDeduplicateWhitespace() {
		return deduplicateWhitespace;
	}

	public void setDeduplicateWhitespace(boolean deduplicateWhitespace) {
		this.deduplicateWhitespace = deduplicateWhitespace;
	}

}
